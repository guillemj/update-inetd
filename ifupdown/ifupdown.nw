%

\def\nwendcode{\endtrivlist\endgroup}
\let\nwdocspar=\relax
\noweboptions{smallcode,webnumbering,hideunuseddefs}

\title{ Interface Tools\thanks{
Copyright \copyright\ 1999 Anthony Towns. This program is free software;
you can redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.
}}

\author{ Anthony Towns \\ { \tt aj@azure.humbug.org.au } }

\pagenumbering{roman}

\maketitle
\tableofcontents

\vfill
\pagebreak
\pagenumbering{arabic}

\section{Introduction}

This source defines the commands [[ifup]] and [[ifdown]], used to
manipulate interfaces in an easily controllable manner.

\subsection{Assumed Knowledge}

The reader is assumed to have knowledge of the C \cite{K&R} and Perl
\cite{camel} programming languages in a Unix environment. A cursory
understanding of network administration on the appropriate platform is
also assumed, along with access to the relevant manual pages as
necessary.

This source has been written as a literate program using the [[noweb]]
\cite{wwwnoweb} tool suite, and typeset using \LaTeX\ \cite{latex}.

\subsection{Program Structure}

We shall decompose this program into four main areas of functionality:
compile-time configuration, run-time configuration, execution, and the
overall driver.

Compile-time configuration will deal with differing available address
families (IPX vs TCP/IP, and so on), and the differing methods of
enabling and disabling interfaces configured for each family. This
will be implemented using the [[addrfam]] module, and various
[[.defn]] files, for the address family definitions.

Run-time configuration will deal with determining the local setup
based on the file [[/etc/network/interfaces]], and producing a data
structure encapsulating these details. This will be implemented in the
[[config]] module.

Execution will deal with issues relating to working out exactly which
commands to run based on a somewhat abstract description from the
compile-time configuration and the details determined at
run-time. This will be dealt with in the [[execute]] module.

The remaining work --- argument parsing, error reporting, and,
essentially, putting all the pieces together --- is done by the
[[main]] module.

We shall find that these modules are too closely linked to be completely
separated in a convenient manner, so they will all make use of a single
header file for each other's structure definitions, exported interfaces
and so on.

<<header.h>>=
#ifndef HEADER_H
#define HEADER_H

<<type definitions>>
<<function type definitions>>
<<structure definitions>>
<<constant definitions>>
<<exported symbols>>

#endif /* HEADER_H */
@ 

\section{The Build System}

We shall begin with the template for the Makefile we shall use.

<<Makefile>>=
<<make options>>

CFILES := addrfam.c execute.c config.c main.c archlinux.c
HFILES := header.h archlinux.h
PERL := defn2c.pl defn2man.pl
DEFNFILES := inet.defn ipx.defn inet6.defn

OBJ := main.o addrfam.o execute.o config.o \
	$(patsubst %.defn,%.o,$(DEFNFILES)) archlinux.o

MAN := $(patsubst %.defn,%.man,$(DEFNFILES))

default : executables
all : executables docs

executables : ifup ifdown ifup.8 ifdown.8 interfaces.5
docs : ifupdown.ps.gz ifupdown.pdf ifup.8.ps.gz interfaces.5.ps.gz

.PHONY : executables 
<<phony targets>>
<<executable targets>>
<<manpage targets>>
<<implicit rules>>

include ifupdown.d
@ 

We shall build exactly two executables, [[ifup]] and [[ifdown]], which
will in truth simply be two names for a single binary, albeit with
different functionality.

<<executable targets>>=
ifup: $(OBJ)
	$(CC) $(CFLAGS) -o ifup $^

ifdown: ifup
	ln -sf ifup ifdown
@ 

Both of these executables have a manpage. Since they're actually the
same executable, what could be more appropriate than them having the
same manpage too?

<<manpage targets>>=
interfaces.5: interfaces.5.pre $(MAN)
	LINE=$$(grep -n '^##ADDRESSFAM##$$' $< | sed 's/:.*//g'); \
	WC=`wc -l < $<`;                                          \
	(                                                         \
	  head -$$[$$LINE - 1] $<;                                \
	  cat $(MAN);                                             \
	  tail -$$[$$WC - $$LINE] $<;                             \
	) > $@

ifdown.8: ifup.8
	ln -sf $< $@

%.5.ps: %.5
	groff -mandoc -Tps $< > $@
%.8.ps: %.8
	groff -mandoc -Tps $< > $@
@ 

Further, for convenience, we'll make use of two phony targets, [[clean]],
[[clobber]] and [[distclean]], which will delete working files, everything
that can be rebuilt with a [[make]] command, and everything that can be
rebuilt at all, respectively.

<<phony targets>>=
.PHONY : clean clobber

install :
	install -m 0755 -d     ${BASEDIR}/sbin
	install -m 0755 ifup   ${BASEDIR}/sbin
	ln ${BASEDIR}/sbin/ifup ${BASEDIR}/sbin/ifdown	

clean :
	rm -f *.aux *.toc *.log *.bbl *.blg *.ps
	rm -f *.o *.d $(patsubst %.defn,%.c,$(DEFNFILES)) *~
	rm -f $(patsubst %.defn,%.man,$(DEFNFILES))
	rm -f ifup ifdown interfaces.5 ifdown.8
	rm -f ifupdown.dvi *.ps{,.gz} ifupdown.pdf

clobber : clean
	rm -f ifupdown.tex $(PERL) $(CFILES) $(HFILES) $(DEFNFILES)

distclean : clobber
	rm -f makecdep.sh makenwdep.sh Makefile
@ 

We have some fairly standard rules to build the printed version of the
source code using \LaTeX\ that are, unfortunately, not included in
[[make(1)]]'s builtin rules, so we'll note them here.

<<implicit rules>>=
%.tex : %.nw
	noweave -index -latex $< >$@

%.bbl : %.tex biblio.bib
	latex $<
	bibtex $(basename $<)

%.dvi : %.tex %.bbl
	latex $<
	latex $<

%.pdf : %.tex %.bbl
	pdflatex $<
	pdflatex $<

%.ps : %.dvi
	dvips -o $@ $<

%.gz : %
	gzip --best --stdout $< >$@
@ 

Additionally, some of [[make]]'s builtin rules are fairly
conservative, so we'll encourage it to use a more entertaining method
of compiling source code.

<<make options>>=
CFLAGS := -Wall -W -g -O2
CC := gcc
@ 

\subsection{Automatic Dependencies}

To build the system, we'll make use of some techniques discussed in
\cite{recursivemake} for determining dependencies. Namely, a number of
files will be associated with a [[.d]] file containing dynamically
determined dependency information. The first such file we will
construct is the dependency information for [[noweb]] source files,
which can be identified by the [[.nw]] extension.

<<implicit rules>>=
%.d: %.nw makenwdep.sh
	./makenwdep.sh $< > $@
@

To construct the dependency information, we may use the [[noroots(1)]]
command to determine the \emph{root chunks} in the [[noweb]] source
(stripping the unwanted [[<<]] and [[>>]] markers as we go, and
denoting that in such a way that [[noweb]] doesn't mistakenly think
the [[sed]] command is a chunk reference itself), and then noting down
appropriate commands to construct the target.

<<makenwdep.sh>>=
<<parse makenwdep arguments>>

noroots $FILE | sed 's/^<''<\(.*\)>>$/\1/' |
	while read chunk; do
		<<output dependency info for [[$chunk]]>>
	done
@ 

Our dependency information is straightforward. To construct a file from
[[noweb]] source, we simply need to run [[notangle(1)]] over it. We add
a couple of extra tweeks in order to only update files that were actually
changed (the [[cpif(1)]] call), and to handle tabs properly.

We also need some extra things to take care of particular types of files.
In particular its important to have our scripts marked executable, so we
can use them as part of the build process itself, and it's also important
to have the dependency information for our C files (which are dealt with
next) included at some point.

<<output dependency info for [[$chunk]]>>=
case $chunk in
	*.pl|*.sh)
		echo -e "$chunk : $FILE"
		echo -e "\tnotangle -R\$@ $< >\$@"
		echo -e "\tchmod 755 $chunk"
		;;
	*.c)
		echo -e "$chunk : $FILE"
		echo -e "\tnotangle -L -R\$@ $< >\$@"
		echo -e "include ${chunk%.c}.d"
		;;
	*.h)
		echo -e "$chunk : $FILE"
		echo -e "\tnotangle -L -R\$@ $< | cpif \$@"
		;;
	*)
		echo -e "$chunk : $FILE"
		echo -e "\tnotangle -t8 -R\$@ $< >\$@"
		;;
esac
@ 

Finally, our fairly primitive argument parsing is simply:

<<parse makenwdep arguments>>=
FILE=$1

if [ "$FILE" = "" -o ! -f "$FILE" ]; then
	echo "Please specify a .nw file"
	exit 1
fi
@ 

We have a related system for object files generated from C source
code. Since each object file depends not only on its source, but also
the headers included in that source, we generate a [[.d]] file indicating
exactly which headers need to be checked.

<<implicit rules>>=
%.d: %.c makecdep.sh
	./makecdep.sh $< > $@
@ 

We can do this using [[gcc(1)]]'s convenient [[-MM -MG]] options,
which do exactly this, with the added proviso that the [[.d]] file
itself can possibly depend on any of the header files being modified
(and, in particular, [[#include]] lines being added or deleted).

<<makecdep.sh>>=
#!/bin/sh
<<parse makecdep arguments>>

gcc -MM -MG $FILE |
  sed -e 's@^\(.*\)\.o:@\1.o \1.d:@'
@ 

\emph{Deja vu}, anyone?

<<parse makecdep arguments>>= 
FILE=$1
if [ "$FILE" = "" -o ! -f "$FILE" ]; then
	echo "Please specify a .c file"
	exit 1
fi
@

\section{Compile Time Configuration}

At compile time we need to determine all the possible address families
that may be used, and all the methods of setting up interfaces for
those address families, along with the various possible options
affecting each method.

Our key definition at this point is that of the [[address_family]]
structure, which encapsulates all the compile time information about
each address family.

<<type definitions>>=
typedef struct address_family address_family;
@ 

<<structure definitions>>=
struct address_family {
	char *name;
	int n_methods;
	method *method;
};
@ 

Each defined address family will be included in the [[addr_fams]]
array, which becomes the \emph{raison d'\^etre} of the [[addrfam]]
module.

<<exported symbols>>=
extern address_family *addr_fams[];
@ 

Each address family incorporates a number of methods, which
encapsulate various ways of configuring an interface for a particular
address family. There are two definining components of a method: two
sets of commands to bring an interface up and down, and a number of
options for the commands.

\emph{NB: I expect this will be extended sooner or later to make the
options more flexible. Probably introducing some form of typing (for
example to convert netmasks from CIDR specs to dotted-quads, ie
/24~$\rightarrow$~255.255.255.0), and some form of matching to allow
multiple options to be deduced from a single configuration
statement. --- aj}

<<type definitions>>=
typedef struct method method;
@ 

<<structure definitions>>=
struct method {
	char *name;
	command_set *up, *down;
};
@ 

Each command set is implemented as a single function, accepting two
parameters: the definitions of the interface the commands should deal
with, and the function that should be used to execute them. See the
[[execute]] module for more details.

<<function type definitions>>=
typedef int (execfn)(char *command);
typedef int (command_set)(interface_defn *ifd, execfn *e);
@ 

As our compile-time configuration is done at, well, compile-time, there
is little need for functions in the actual module, and we can make do with
a single exported array.

<<addrfam.c>>=
#include <stdlib.h>
#include "header.h"

<<address family declarations>>

address_family *addr_fams[] = {
	<<address family references>>
	NULL
};
@ 

\subsection{Generating C Code}

Unfortunately, while the [[.defn]] representation is reasonably
convenient for human use, it's less convenient for a compiler. As
such, at build time, we will build a single structure of type
[[address_family]] in a separate module, and reference that from
[[addrfam.c]].

Naturally, we'll use a [[perl]] script to convert [[.defn]] files to C
code.

<<implicit rules>>=
%.c : %.defn defn2c.pl
	./defn2c.pl $< > $@
@ 

The functionality of our program is pretty basic: read from the file
specified as the argument, output to [[stdout]]; and correspondingly
the structure of the program is similarly simple. We make use of a
couple of global variables, a few helpful subroutines, and then build
our C program.

<<defn2c.pl>>=
#!/usr/bin/perl -w

use strict;

# declarations
<<defn2c variables>>

# subroutines
<<defn2c subroutines>>

# main code
<<output headers for address family>>
<<parse [[.defn]] file and output intermediate structures>>
<<output address family data structure>>
@ 

Clearly we need to reference some of the data structures we defined
above, so we can begin with the rather trivial:

<<output headers for address family>>=
print "#include \"header.h\"\n\n\n";
@ 

The overall purpose of the C code we're trying to construct is to
define a structure of type [[address_family]], and have it externally
visible. So we'd like to declare a statically-initialized structure of
this type, and be done with it.

To do this, however, we need to have some way of uniquely identifying
the structure to avoid naming conflicts. We'll do this by assuming we
have a previously initialized variable, [[$address_family]], and that
names of the form [[addr_foo]] won't be used elsewhere.

<<defn2c variables>>=
my $address_family = "";
@

We also need to reference an array of pointers to this address
family's [[method]]s, which will have to be initialized separately.
We'll assume that previous code will create such a structure, and call
it (imaginativly) [[methods]].

<<output address family data structure>>=
<<output [[methods]] data structure>>

print <<EOF;
address_family addr_${address_family} = {
	"$address_family",
	sizeof(methods)/sizeof(struct method),
	methods
};
EOF
@ 

Our [[methods]] array will be a little more complicated to
construct. The first difficulty is that it will actually require some
state from having read the [[.defn]] file. To handle this, we'll
introduce a hash [[%methods]] that has the value [[1]] for each method
from the [[.defn]] file. We use a hash instead of a list because it
makes some error checking more convenient later, and since order
doesn't particularly matter.

<<defn2c variables>>=
my %methods = ();
@

We'll use standard names, such as [[foo_up]], [[foo_down]], and
[[foo_options]] for the various elements of each method which cannot
be defined inline. The two functions and the array will be declared
static to avoid name conflicts.

<<output [[methods]] data structure>>=
print "static method methods[] = {\n";
my $method;
foreach $method (keys %methods) {
	print <<EOF;
	{
		"$method",
		${method}_up, ${method}_down,
	},
EOF
}
print "};\n\n";
@ 

In a reasonably obvious manner we can then proceed to process the
[[.defn]] file to initialize the aforementioned variables, and to
output the method-specific functions and array. We'll begin by
defining a variable to keep track of the current line.

<<defn2c variables>>=
my $line = "";
@ 

Our semantics for this variable will be basically that it contains a
valid, meaningful input line. It won't be blank, or contain comments,
and if there aren't any more lines to be read, it will evaluate to
[[false]]. In order to keep these semantics, we'll use the subroutine
[[nextline]] to update it. (Since we'll later find we'll want to reuse
this subroutine, we'll keep it in a chunk of its own)

<<defn2c subroutines>>=
<<[[nextline]] subroutine>>
@ 

<<[[nextline]] subroutine>>=
sub nextline {
	$line = <>;
	while($line and ($line =~ /^#/ or $line =~ /^\s*$/)) {
		$line = <>;
	}
	if (!$line) { return 0; }
	chomp $line;
	while ($line =~ m/^(.*)\\$/) {
		my $addon = <>;
		chomp $addon;
		$line = $1 . $addon;
        }
	return 1;
}
@ 

Our high-level logic then looks basically like:

<<parse [[.defn]] file and output intermediate structures>>=
nextline;
while($line) {
	<<parse a top-level section and output intermediate structures>>

	# ...otherwise
	die("Unknown command \"$line\"");
}
@

To make all this stuff easier, we'll use a `matching' function to help
with parsing lines: basically, given a line, a command, and possibly
an indentation prefix (eg [["    "]]). (As with [[nextline]], this will
also be useful to reuse, hence it has its own pair of chunks, too)

<<defn2c variables>>=
my $match = "";
@ 

<<defn2c subroutines>>=
<<[[match]] subroutine>>
@ 

<<[[match]] subroutine>>=
sub match {
	my $line = $_[0];
	my $cmd = "$_[1]" ? "$_[1]\\b\\s*" : "";;
	my $indentexp = (@_ == 3) ? "$_[2]\\s+" : "";

	if ($line =~ /^${indentexp}${cmd}(([^\s](.*[^\s])?)?)\s*$/) {
		$match = $1;
		return 1;
	} else {
		return 0;
	} 
}
@ 

Okay. So, the first line we expect to see is the name of the address
family we're defining.

<<parse a top-level section and output intermediate structures>>=
if (match($line, "address_family")) {
	get_address_family $match;
	next;
}
@ 

This is, as you'd imagine, pretty simple to deal with. We just need to
store the address family's name, and move on to the next line.

<<defn2c subroutines>>=
sub get_address_family {
	$address_family = $_[0] if ($address_family eq "");
	nextline;
}
@ 

Which brings us to determining the architecture.

<<parse a top-level section and output intermediate structures>>=
if (match($line, "architecture")) {
	get_architecture $match;
	next;
}
@ 

You'd never guess what, but it's just as easy as the address family thing
was.

<<defn2c subroutines>>=
sub get_architecture {
	my $arch = $_[0];
	die("architecture declaration appears too late") if (keys %methods);
	print "#include \"arch${arch}.h\"\n\n\n";
	nextline;
}
@ 

Which leaves us with the hard bit, actually creating the functions and
array for each method.

<<parse a top-level section and output intermediate structures>>=
if (match($line, "method")) {
	get_method $match;
	next;
}
@

The basic premise is to check for each of our options in a given
order: if they don't match, then we can presume they don't exist ---
any errors will be reported when the main function finds something
weird going on. All we really have to take care of so far is ensuring
an appropriate level of indentation, and that we're not defining the
same method twice.

<<defn2c subroutines>>=
sub get_method {
	my $method = $_[0];
	my $indent = ($line =~ /(\s*)[^\s]/) ? $1 : "";

	die "Duplicate method $method\n" if ($methods{$method}++);

	nextline;
	<<output code for description>>
	<<output code for options list>>
	<<output code for up commands>>
	<<output code for down commands>>
}
@ 

The description and options sections are just documentation chunks,
and hence aren't at all relevant for the C code.

<<output code for description>>=
if (match($line, "description", $indent)) {
	skip_section();
}
@ 

<<output code for options list>>=
if (match($line, "options", $indent)) {
	skip_section();
}
@ 

Skipping a section is fairly easy: we just need to check alignments. This is
yet another subroutine that'll come in handy elsewhere.

<<defn2c subroutines>>=
<<[[skip_section]] subroutine>>
@ 

<<[[skip_section]] subroutine>>=
sub skip_section {
	my $struct = $_[0];
	my $indent = ($line =~ /(\s*)[^\s]/) ? $1 : "";

	1 while (nextline && match($line, "", $indent));
}
@ 

Checking the various relevant components of each method is fairly
simple: we need to see if it exists, and if it does, parse and output
it, while if it doesn't, we need to output a place holder.

<<output code for up commands>>=
if (match($line, "up", $indent)) {
	get_commands(${method}, "up");
} else {
	print "static int ${method}_up(interface_defn ifd) { return 0; }\n"
}
@ 

<<output code for down commands>>=
if (match($line, "down", $indent)) {
	get_commands(${method}, "down");
} else {
	print "static int ${method}_down(interface_defn ifd) { return 0; }\n"
}
@

<<defn2c subroutines>>=
sub get_commands {
	my $method = $_[0];
	my $mode = $_[1];
	my $function = "${method}_${mode}";
	my $indent = ($line =~ /(\s*)[^\s]/) ? $1 : "";

	print "static int ${function}(interface_defn *ifd, int (*exec)(char*)) {\n";

	while (nextline && match($line, "", $indent)) {
		if ( $match =~ /^(.*[^\s])\s+if\s*\((.*)\)\s*$/ ) {
			print "if ( $2 ) { if (!execute(\"$1\", ifd, exec)) return 0; }\n";
		} elsif ( $match =~ /^(.*[^\s])\s+elsif\s*\((.*)\)\s*$/ ) {
			print "else if ( $2 ) { if (!execute(\"$1\", ifd, exec)) return 0; }\n";
		} else {
			print "{ if (!execute(\"$match\", ifd, exec)) return 0; }\n";
		}
	}

	print "return 1;\n";
	print "}\n";
}
@ 

\subsection{Building Manual Pages}

So having C code is all very well, but if you want to ignore all user
problems with a casual ``RTFM!'' there has to be some semblance of an
M for them to R. So we need a script to generate some useful
descriptions of the various methods.

We'll achieve this by making another Perl script, [[defn2man.pl]],
which will generate fragments of [[troff]] that can be catted together
with a general overview of [[ifupdown]] to produce real manpages.

<<implicit rules>>=
%.man: %.defn defn2man.pl
	./defn2man.pl $< > $@
@ 

So we'll use a similar structure to [[defn2c.pl]].

<<defn2man.pl>>=
#!/usr/bin/perl -w

use strict;

# declarations
<<defn2man variables>>

# subroutines
<<defn2man subroutines>>

# main code
<<parse [[.defn]] file and output manpage fragment>>
@ 

As predicted, we'll also incorporate [[nextline]], [[match]] and
[[skip_section]]:

<<defn2man variables>>=
my $line;
my $match;
@ 

<<defn2man subroutines>>=
<<[[nextline]] subroutine>>
<<[[match]] subroutine>>
<<[[skip_section]] subroutine>>
@ 

Now we'll have a slightly different structure to the program itself
this time, since we need to do things pretty much in order for
outputting the manpage. This imposes stricter ordering requirements on
the [[.defn]] files than [[defn2c]] did.

<<parse [[.defn]] file and output manpage fragment>>=
nextline;
if ($line and match($line, "address_family")) {
	get_address_family $match;
} else {
	die "address_family must be listed first\n";
}
if ($line and match($line, "architecture")) {
	get_architecture $match;
}
while ($line and match($line, "method")) {
	get_method $match;
}
@ 

Okay, so it wasn't \emph{that} different from what we had before. Sue
me.

The [[get_address_family]] and [[get_architecture]] subroutines are
fairly straight forward:

<<defn2man subroutines>>=
sub get_address_family {
	print ".SH " . uc($match) . " ADDRESS FAMILY\n";
	print "This section documents the methods available in the\n";
	print "$match address family.\n";
	nextline;
}
@ 

<<defn2man subroutines>>=
sub get_architecture {
	# no op
	nextline;
}
@ 

Which only leaves extracting the description and options for each
method. And, of course, this imposes less restrictions of the
[[.defn]] file than [[defn2c.pl]] did. It's a crazy old world.

<<defn2man subroutines>>=
sub get_method {
	my $method = shift;
	my $indent = ($line =~ /(\s*)\S/) ? $1 : "";
	my $description = "";
	my @options = ();
	
	nextline;
	while ($line and match($line, "", $indent)) {
		if (match($line, "description", $indent)) {
			$description = get_description();
		} elsif (match($line, "options", $indent)) {
			@options = get_options();
		} else {
			skip_section;
		}
	}

	<<output [[$method]] introduction man fragment>>
	<<output [[$description]] man fragment>>
	<<output [[@options]] man fragment>>
}
@

<<output [[$method]] introduction man fragment>>=
print ".SS The $method Method\n";
@ 

Okay. Now our [[$description]] is just the description with any [['\n']]
characters it may've had, but without the leading spaces.

<<defn2man subroutines>>=
sub get_description {
	my $desc = "";
	my $indent = ($line =~ /(\s*)\S/) ? $1 : "";
	while(nextline && match($line, "", $indent)) {
		$desc .= "$match\n";
	}
	return $desc;
}
@ 

We're actually going to be a little tricky here, and allow some formatting
in our descriptions. Basically, we'll allow bold and italic encoding
to be denoted by [[*bold*]] and [[/italics/]] in the wonderful Usenet
tradition. As such, we'll use a cute little function to convert the
Usenet style, to roff. Voila:

<<defn2man subroutines>>=
sub usenet2man {
	my $in = shift;
	my $out = "";

	$in =~ s/\s+/ /g;
	while ($in =~ m/^([^\*\/]*)([\*\/])([^\*\/]*)\2\s*(.*)$/s) { 
		$out .= "$1\n" . ($2 eq "*" ? ".B" : ".I") . " \"$3\"\n";
		$in = $4;
	} 
	return $out . $in;
}
@

The only further thing to note about this is that we're being careless
and ignoring the possibility of ROFF escape sequences in the input. But
since this is for internal use only, well, too bad. So here we go:

<<output [[$description]] man fragment>>=
if ($description ne "") {
	print usenet2man($description) . "\n";
} else {
	print "(No description)\n";
}
@ 

Damn that was fun.

Reading the options is almost exactly the same as the description,
except we want a list instead of just a string.

<<defn2man subroutines>>=
sub get_options {
	my @opts = ();
	my $indent = ($line =~ /(\s*)\S/) ? $1 : "";
	while(nextline && match($line, "", $indent)) {
		push @opts, $match;
	}
	return @opts;
}
@ 

Output is slightly more complicated, but not too much so.

<<output [[@options]] man fragment>>=
print ".PP\n";
print ".B Options\n";
print ".RS\n";
if (@options) {
	foreach my $o (@options) {
		if ($o =~ m/^\s*(\S*)\s*(.*)\s+--\s+(\S.*)$/) {
			my $opt = $1;
			my $optargs = $2;
			my $dsc = $3;
			print ".TP\n";
			print ".BI $opt";
			print " \" $optargs\"" unless($optargs =~ m/^\s*$/);
			print "\n";
			print usenet2man($dsc) . "\n";
		} else {
			print ".TP\n";
			print ".B $o\n";
		}
	}
} else {
	print ".TP\n";
	print "(No options)\n";
}
print ".RE\n";
@ 

\section{Run-time Configuration}

Our module is of the usual form, and we'll make use of a few fairly standard
headers. Please move along, there's nothing to see here.

<<config.c>>=
<<config headers>>
<<config function declarations>>
<<config functions>>
@ 

<<config headers>>=
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
@ 

We'll also make use of some of our other modules. This is, after all,
why we had a single header in the first place.

<<config headers>>=
#include "header.h"
@ 

The key function we're interested in defining here is
[[read_interfaces()]], which will (wait for it) read an interfaces
file. The intention is to make it really easy to deal with the
vagaries of [[/etc/network/interfaces]] anywhere else.

So the first question we need to deal with is ``What's a convenient form for
other functions which deal with interfaces?'' Our answer is basically a
singly linked list of structures that essentially reflect the original
configuration file.

At run-time, we require a way of representing each interface listed in
the configuration file. This naturally needs to reference an address
family and method, and all the options a user may specify about an
interface.

<<type definitions>>=
typedef struct interface_defn interface_defn;
@ 

<<structure definitions>>=
struct interface_defn {
	interface_defn *next;

	char *iface;
	char *scheme;
	address_family *address_family;
	method *method;

	int automatic;

	int max_options;
	int n_options;
	variable *option;
};
@

The last component in the above, the options, is represented by a
series of name/value pairs. \emph{This is almost certain to change ---
aj}.

<<type definitions>>=
typedef struct variable variable;
@ 

<<structure definitions>>=
struct variable {
	char *name;
	char *value;
};
@ 

We can thus begin to instantiate our actual function. What we want is
something that, given the name of a file, will produce the appropriate
linked list of interfaces defined in it, or possibly give some sort of
helpful error message. Pretty simple, hey?

<<exported symbols>>=
interface_defn *read_interfaces(char *filename);
@ 

<<config functions>>=
interface_defn *read_interfaces(char *filename) {
	<<variables local to read interfaces>>
	interface_defn *ifaces = NULL;

	<<open file or [[return NULL]]>>

	while (<<we've gotten a line from the file>>) {
		<<process the line>>
	}
	if (<<an error occurred getting the line>>) {
		<<report internal error and die>>
	}

	<<close file>>

	return ifaces;
}
@ 

\subsection{File Handling}

So, the first and most obvious thing to deal with is the file
handling. Nothing particularly imaginative here.

<<variables local to read interfaces>>=
FILE *f;
@ 

<<open file or [[return NULL]]>>=
f = fopen(filename, "r");
if ( f == NULL ) return NULL;
@

<<close file>>=
fclose(f);
@

\subsection{Line Parsing}

Our next problem is to work out how to read a single line from our
input file. While this is nominally easy, we also want to deal nicely
with things like continued lines, comments, and very long lines.

So we're going to have to write and make use of a complicated little
function, which we'll imaginatively call [[get_line()]]. It will need
a pointer to the file it's reading from, as well as a buffer to store
the line it finds. Since this buffer's size can't be known in advance
we'll need to make it [[realloc()]]-able, which means we need to pass
around references to both the buffer's location (which may change),
and it's size (which probably will). Our function declaration is thus:

<<config function declarations>>=
static int get_line(char **result, size_t *result_len, FILE *f);
@ 

To use it, we'll need a couple of variables to stores the buffer's
location, and it's current length.

<<variables local to read interfaces>>=
char *buf = NULL;
size_t buf_len = 0;
@ 

Given these, and presuming we can actually implement the function, our
key chunk can thus be implemented simply as:

<<we've gotten a line from the file>>=
get_line(&buf,&buf_len,f)
@ 

We'll also add the requirement that errors are indicated by the
[[errno]] variable being non-zero, which is usual and reasonable for
all the circumstances where [[get_line()]] might have problems.

<<config headers>>=
#include <errno.h>
@ 

<<an error occurred getting the line>>=
errno != 0
@ 

Actually defining the function is, as you'd probably imagine, a little
more complicated. We begin by reading a line from the file. If it was
a comment (that is, it has a [[#]] character at the first non-blank
position) then we try again. Otherwise, if the line is continued
(indicated by a [[\]] character at the very end of the line) we append
the next line to the buffer. We go to a little bit of effort to trim
whitespace, and finally return a boolean result indicating whether we
got a line or not.

<<config functions>>=
static int get_line(char **result, size_t *result_len, FILE *f) {
	<<variables local to get line>>
	
	do {
		<<clear buffer>>
		<<append next line to buffer, or [[return 0]]>>
		<<trim leading whitespace>>
	} while (<<line is a comment>>);

	while (<<buffer is continued>>) {
		<<remove continuation mark>>
		<<append next line to buffer, or [[return 0]]>>
	}

	<<trim trailing whitespace>>

	return 1;
}
@ 

In order to do string concatenation efficiently, we'll keep track of
where the end of the line so far is --- this is thus where the
terminating [[NUL]] will be by the end of the function.

<<variables local to get line>>=
size_t pos;
@ 

We can thus clear the buffer by simply resetting where we append new
text to the beginning of the buffer. What could be simpler?

<<clear buffer>>=
pos = 0;
@ 

We'll be making use of the [[fgets()]] function to read the line
(rather than, say, [[fgetc()]]) so to get an entire line we may have
to make multiple attempts (if the line is bigger than our
buffer). Realising this, and the fact that we may not have any
allocated space for our buffer initially, we need a loop something
like:

<<append next line to buffer, or [[return 0]]>>=
do {
	<<reallocate buffer as necessary, or [[return 0]]>>
	<<get some more of the line, or [[return 0]]>>
} while(<<the line isn't complete>>);

<<remove trailing newline>>

assert( (*result)[pos] == '\0' );
@ 

When reallocating the buffer, we need to make sure it increases in
chunks large enough that we don't have to do this too often, but not
so huge that we run out of memory just to read an 81 character line.
We'll use two fairly simple heuristics for this: if we've got room to
add no more than 10 characters, we may as well reallocate the buffer,
and when reallocating, we want to more or less double the buffer, but
we want to at least add 80 characters. So we do both.

<<reallocate buffer as necessary, or [[return 0]]>>=
if (*result_len - pos < 10) {
	char *newstr = realloc(*result, *result_len * 2 + 80);
	if (newstr == NULL) {
		return 0;
	}
	*result = newstr;
	*result_len = *result_len * 2 + 80;
}
@ 

The only time we need to keep reading is when the buffer wasn't big
enough for the entire line. This is indicated by a full buffer, with
no newline at the end. There is, actually, one case where this can
happen legitimately --- where the last line of the file is
\emph{exactly} the length of the buffer. We need to detect this
because [[fgets()]] will return [[NULL]] and indicate that it's hit
the end of the file, but we won't want to indicate that until the
\emph{next} time we try to get a line. Complicated, isn't it?

<<the line isn't complete>>=
pos == *result_len - 1 && (*result)[pos-1] != '\n'
@ 

So having thought through all that, actually working with [[fgets()]]
is fairly simple, especially since we deal with the actual errors
elsewhere. All we need to do is make the call, update [[pos]] and
check that the problems [[fgets()]] may have actually bother us.

<<get some more of the line, or [[return 0]]>>=
if (!fgets(*result + pos, *result_len - pos, f)) {
	if (errno == 0 && pos == 0) return 0;
	if (errno != 0) return 0;
}
pos += strlen(*result + pos);
@ 

[[fgets()]] leaves a [[\n]] in our buffer in some cases. We're never
actually interested in it, however, so it's a good move to get rid of
it.

<<remove trailing newline>>=
if (pos != 0 && (*result)[pos-1] == '\n') {
	(*result)[--pos] = '\0';
}
@ 


Pretty simple, hey? Now the next thing we want to do is get rid of
some of the whitespace lying about. This is all pretty basic, and just
involves finding where the whitespace begins and ends, and, well,
getting rid of it.

<<config headers>>=
#include <ctype.h>
@ 

<<trim leading whitespace>>=
{ 
	int first = 0; 
	while (isspace((*result)[first]) && (*result)[first]) {
		first++;
	}

	memmove(*result, *result + first, pos - first + 1);
	pos -= first;
}
@ 

<<trim trailing whitespace>>=
while (isspace((*result)[pos-1])) { /* remove trailing whitespace */
	pos--;
}
(*result)[pos] = '\0';
@ 

As we mentioned earlier, a line is a comment iff it's first character
is a [[#]] symbol. Similarly, it's continued iff it's very last
character is a [[\]]. And, rather obviously, if we want to remove a
single trailing [[\]], we can do so by changing it to a [[NUL]].

<<line is a comment>>=
(*result)[0] == '#'
@ 

<<buffer is continued>>=
(*result)[pos-1] == '\\'
@ 

<<remove continuation mark>>=
(*result)[--pos] = '\0';
@ 

\subsection{Line Processing}

So. We've gone to a lot of trouble to get a line that we can parse
with a snap of our fingers, so we probably better snap to it, to mix
some \emph{clich\'e's}.

We have two bits of state that need to be maintained between lines,
namely the name of the current scheme and the various details we've
already obtained about the interface we're currently working with.

<<variables local to read interfaces>>=
char scheme[80] = "*";
interface_defn *currif = NULL;
@ 

Since our configuration files are pretty basic, we can work out what
any particular line means based on the first word in it. To cope with
this, we'll thus make use of a couple of variables, one to store the
first word, and the other to store the rest of the line.

<<variables local to read interfaces>>=
char firstword[80];
char *rest;
@ 

To initialize these variables we'll make use of a function I'm overly
fond of called [[next_word()]]. It copies the first word in a string
to a given buffer, and returns a pointer to the rest of the buffer.

<<config function declarations>>=
static char *next_word(char *buf, char *word, int maxlen);
@

<<config functions>>=
static char *next_word(char *buf, char *word, int maxlen) {
	if (!buf) return NULL;
	if (!*buf) return NULL;

	while(!isspace(*buf) && *buf) {
		if (maxlen-- > 1) *word++ = *buf;
		buf++;
	}
	if (maxlen > 0) *word = '\0';

	while(isspace(*buf) && *buf) buf++;

	return buf;
}
@ 

So after all this, there are basically three different sorts of line
we can get: the start of a new scheme, the start of a new interface or
an option for whatever interface we're currently working with.

<<process the line>>=
rest = next_word(buf, firstword, 80);
if (rest == NULL) continue; /* blank line */

if (strcmp(firstword, "scheme") == 0) {
	<<process [[scheme]] line>>
} else if (strcmp(firstword, "iface") == 0) {
	<<process [[iface]] line>>
} else {
	<<process option line>>
}
@ 

\subsubsection{Scheme line}

Coping with a new scheme is embarassingly easy --- all we need to do
is change the [[scheme]] value to be whatever the next word in the
line was.

<<process [[scheme]] line>>=
rest = next_word(rest, scheme, 80);
if (!rest) {
	<<report missing scheme name and die>>
}
@

\subsubsection{Interface line}

Declaring a new interface is somewhat more interesting.

<<process [[iface]] line>>=
{
	<<variables local to process [[iface]] line>>

	<<allocate new interface>>

	<<parse interface settings>>

	<<set iface name>>
	<<set scheme>>
	<<set address family>>
	<<set method>>
	<<set other options to defaults>>

	<<add to list of interfaces>>
}
@ 

We'll deal with each of these phases one by one and pretty much in
order, so prepare yourself for the intense excitement of memory
allocation!

<<allocate new interface>>=
currif = malloc(sizeof(interface_defn));
if (!currif) {
	<<report internal error and die>>
}
@ 

When we introduce a new interface, we simultaneously name the
interface, the address family, and the method. We cope with this by,
well, getting somewhere to store each of them, and then, well, storing
them. Action! Drama!

<<variables local to process [[iface]] line>>=
char iface_name[80];
char address_family_name[80];
char method_name[80];
@ 

<<parse interface settings>>=
rest = next_word(rest, iface_name, 80);
rest = next_word(rest, address_family_name, 80);
rest = next_word(rest, method_name, 80);

if (rest == NULL) {
	<<report too few parameters for iface line and die>>
}

if (rest[0] != '\0') {
	<<report too many parameters for iface line and die>>
}
@ 

We then want to store the interface and scheme names. Crazy! Never to
be repeated!

<<set iface name>>=
currif->iface = strdup(iface_name);
if (!currif->iface) {
	<<report internal error and die>>
}    
@ 

<<set scheme>>=
currif->scheme = strdup(scheme);
if (!currif->scheme) {
	<<report internal error and die>>
}
@ 

Setting the address family is a little more involved, because it's not
very useful to know what the name of the address family is, you really
want to know all the details recorded in the appropriate
[[address_family]] structure. So we'll make use of a little helper
function, called [[get_address_family()]] to convert the useless
string, to the hopefully less useless structure.

<<config function declarations>>=
static address_family *get_address_family(address_family *af[], char *name);
@ 

<<set address family>>=
currif->address_family = get_address_family(addr_fams, address_family_name);
if (!currif->address_family) {
	<<report unknown address family and die>>
}
@ 

Of course, we probably need to actually implement the function too. We
won't do anything particularly fancy here, just a simple linear
search. \emph{Should this really be here, or an exported symbol from
[[addrfam.c]]? --- aj}

<<config functions>>=
static address_family *get_address_family(address_family *af[], char *name) {
	int i;
	for (i = 0; af[i]; i++) {
		if (strcmp(af[i]->name, name) == 0) {
			return af[i];
		}
	}
	return NULL;
}
@

We do something incredibly similar when dealing with the method the
user wishes to use, and we do it for incredibly similar reasons. Again
we declare a cute little helper function, this time imaginatively
called [[get_method()]], and then go and use it and implement in
almost exactly the same way as before. I told you this was going to be
a thrill. \emph{The same note applies here, too --- aj}

<<config function declarations>>=
static method *get_method(address_family *af, char *name);
@ 

<<set method>>=
currif->method = get_method(currif->address_family, method_name);
if (!currif->method) {
	<<report unknown method and die>>
	return NULL; /* FIXME */
}
@

<<config functions>>=
static method *get_method(address_family *af, char *name) {
	int i;
	for (i = 0; i < af->n_methods; i++) {
		if (strcmp(af->method[i].name, name) == 0) {
			return &af->method[i];
		}
	}
	return NULL;
}
@

You'll continue to be enthralled as we set the remaining options to
some default values. Hurray! Yippee!

<<set other options to defaults>>=
currif->automatic = 1;
currif->max_options = 0;
currif->n_options = 0;
currif->option = NULL;
@ 

Since we want to keep the interfaces in order, we have to go all the
way to the end of the list of interfaces to add the new interface, and
we can hence set the [[next]] pointer to NULL in all cases. Gee. Whiz.

Actually, I'm selling this a little short. We also want to make sure
we don't try instantiating the same interface twice or anything. So we
take care of that too. There now. Didn't that just get the adrenalin
pumping?

<<add to list of interfaces>>=
currif->next = NULL;

if (ifaces == NULL) {
	ifaces = currif;
} else {
	interface_defn *checkif;
	checkif = ifaces; 
	for(;;) {
		if (duplicate_if(checkif, currif)) {
			<<report duplicate interface and die>>
		}
		if (!checkif->next) break;
		checkif = checkif->next;
	}

	checkif->next = currif;
}
@ 

Duplicate interfaces are interfaces that share the same scheme,
interface name and address family --- while they may have different
methods, that alone just isn't enough to differentiate them.

\emph{There are two issues here. First, is that since schemes are
actually shell globs, having them be different isn't actually enough
to make sure they're not repeated. But I don't want to leave them as
shell globs anyway, so this will kinda resolve itself. The second
issue, is that duplicate interfaces can be interesting, if you can rig
it up so that, for example, it first tries dhcp, then bootp, then
gives up and uses a static address. This sort of consideration will
probably have to be dealt with by the sysadmin though, rather than in
here. So we'll choose not to make duplicate interfaces meaningful. ---
aj}

<<config function declarations>>=
static int duplicate_if(interface_defn *ifa, interface_defn *ifb);
@ 

<<config functions>>=
static int duplicate_if(interface_defn *ifa, interface_defn *ifb) {
	if (strcmp(ifa->scheme, ifb->scheme) != 0) return 0;
	if (strcmp(ifa->iface, ifb->iface) != 0) return 0;
	if (ifa->address_family != ifb->address_family) return 0;
	return 1;
}
@ 

Stay tuned for more action and adventure.

\subsubsection{Options line}

The final sort of line we have to deal with are interface options. The
basic structure of this is fairly straightforward --- the only option
we deal with specially is the [[noauto]] option.

<<process option line>>=
if (!currif) {
	<<report option without interface and die>>
} else {
	if (strcmp(firstword,"noauto") == 0) {
		currif->automatic = 0;
	} else {
		<<add option>>
	}
}
@ 

Adding an option is also fairly straightforward: we simply construct a
new variable and add it at the end of our array of variables, increasing
the size of the array first if necessary. 

<<add option>>=
if (currif->n_options >= currif->max_options) {
	<<increase max number of options>>
}

currif->option[currif->n_options].name = strdup(firstword);
currif->option[currif->n_options].value = strdup(rest);

if (!currif->option[currif->n_options].name) {
	<<report internal error and die>>
}

if (!currif->option[currif->n_options].value) {
	<<report internal error and die>>
}

currif->n_options++;	
@

We'll increase the space for variables by a constant amount each time,
rather than doubling or anything smart like that.

<<increase max number of options>>=
{
	variable *opt;
	currif->max_options = currif->max_options + 10;
	opt = realloc(currif->option, sizeof(variable) * currif->max_options);
	if (opt == NULL) {
		<<report internal error and die>>
	}
	currif->option = opt;
}
@ 

\subsection{Error Handling}

We don't do anything too fancy about handling errors that occur, we
just print out a hopefully helpful error message, and return from the
function. \emph{We probably should also go to some effort to close
files, and free memory, but well. Maybe version $n+1$. --- aj}

<<report internal error and die>>=
perror(filename);
return NULL;
@ 

<<report missing scheme name and die>>=
fprintf(stderr, "%s: scheme name missing\n", filename);
return NULL;
@ 

<<report too few parameters for iface line and die>>=
fprintf(stderr, "%s: too few parameters for iface line\n", filename);
return NULL;
@

<<report too many parameters for iface line and die>>=
fprintf(stderr, "%s: too many parameters for iface line\n", filename);
return NULL;
@

<<report unknown address family and die>>=
fprintf(stderr, "%s: unknown address type\n", filename);
return NULL;
@

<<report unknown method and die>>=
fprintf(stderr, "%s: unknown method\n", filename);
return NULL;
@

<<report duplicate interface and die>>=
fprintf(stderr, "%s: duplicate interface\n", filename);
return NULL;
@

<<report option without interface and die>>=
fprintf(stderr, "%s: option without interface\n", filename);
return NULL;
@

\section{Execution}

The [[execute]] module will be laid out in the standard manner, and
will make use of the usual header files.

<<execute.c>>=
<<execute headers>>
<<execute function declarations>>
<<execute functions>>
@ 

<<execute headers>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "header.h"
@

The key function we'll export from here is [[execute()]], which, given
a command, an interface will fill in any missing details in the
command, and execute it.

<<exported symbols>>=
int execute(char *command, interface_defn *ifd, execfn *exec);
@ 

At the somewhat abstract level, this is fairly trivial. The devil is
in the details of the parsing, which makes up the rest of the module.

<<execute functions>>=
int execute(char *command, interface_defn *ifd, execfn *exec) { 
	char *out;
	int ret;

	out = parse(command, ifd);
	if (!out) { return 0; }

	ret = exec(out);
  
	free(out);
	return ret;
}
@ 

\subsection{Command Parsing}

We'll need a basic parser function, which we'll call [[parse()]] to
make the appropriate substitutions into a command. It's probably worth
a note as to exactly what substitutions may be made:

\begin{itemize}

	\item Special characters can be escaped with a backslash. eg
	[[ls MoreThan80\%]].

	\item Variables can be substituted by including their name
	delimeted by percents. eg [[ls %directory%]].

	\item Optional components may be enclosed in double square
	brackets. Optional components will be included exactly when
	every variable referenced within exists. eg
	[[ls [[--color=%color%]]][[] %directory%]]. Optional components
	may be nested.

\end{itemize}

Most of the parsing is fairly straightforward -- basically, we keep an
output buffer, and add things to it as we stroll through the input
buffer: either the actual character we want, or whatever the value of
the variable we're looking at is, or whatever. The only particularly
complicated bit is how we deal with the optional sections, which will
be explained when we get to them.

<<execute function declarations>>=
static char *parse(char *command, interface_defn *ifd);
@ 

<<execute functions>>=
static char *parse(char *command, interface_defn *ifd) {
	<<variables local to parse>>

	while(*command) {
		switch(*command) {
			<<handle a token>>
		}
	}

	<<deal with error conditions>>

	<<return result>>
}
@

\subsubsection{Maintain output buffer}

So the first thing we need to do is actually write some code to deal
with the output buffer, which will need to be dynamically resized and
so on to take care of possibly long strings and what-not. It is the
caller's responsibility to [[free()]] this buffer. We'll maintain two
extra variables for convenience: who much memory we've allocated
[[len]], and where the next character should be stuck [[pos]].

<<variables local to parse>>=
char *result = NULL;
size_t pos = 0, len = 0;
@ 

This makes it pretty easy to return the result to the caller, too.

<<return result>>=
return result;
@

The main thing to be done to this buffer is to add characters or
strings to it. To deal with this, we'll make use of an [[addstr()]]
function that resizes the buffer as necessary, and appends a string to
it. So we can deal with single characters, and substrings in general,
we'll specify the string to be added as a pointer-length combination,
rather than as a [[NUL]] terminated string.

<<execute function declarations>>=
void addstr(char **buf, size_t *len, size_t *pos, char *str, size_t strlen);
@ 

<<execute functions>>=
void addstr(char **buf, size_t *len, size_t *pos, char *str, size_t strlen) {
	assert(*len >= *pos);
	assert(*len == 0 || (*buf)[*pos] == '\0');

	if (*pos + strlen >= *len) {
		char *newbuf;
		newbuf = realloc(*buf, *len * 2 + strlen + 1);
		if (!newbuf) {
			perror("realloc");
			exit(1); /* a little ugly */
		}
		*buf = newbuf;
		*len = *len * 2 + strlen + 1;
	}
	
	while (strlen-- >= 1) {
		(*buf)[(*pos)++] = *str;
		str++;
	}
	(*buf)[*pos] = '\0';
}
@ 

Given this, we can define our default behaviour for a character:

<<handle a token>>=
default:
	addstr(&result, &len, &pos, command, 1);
	command++;
	break;
@ 

\subsubsection{Escaped characters}

We can also deal pretty simply with escaped tokens. The only special
circumstance is if the [[\]] is at the very end of string. We don't
want buffer overflows afterall.

<<handle a token>>=
case '\\':
	if (command[1]) {
		addstr(&result, &len, &pos, command+1, 1);
		command += 2;
	} else {
		addstr(&result, &len, &pos, command, 1);
		command++;
	}
	break;
@ 

\subsubsection{Optional components}

Basically we keep track of each optional section we're in, whether
we've been unable to fill in any variables, and where we started
it. When we reach the end of an optional section, we check to see if
we were unable to fill in any variables, and, if so, we discard any
text we'd added within that block. This also allows us to neatly check
for any errors trying to fill in variables that aren't in optional
sections.

Basically what we'll do here is keep one stack to represent where the
various thingos started, and another to represent whether any
variables didn't exist. We'll use the bottom-most entry in the stack
to represent the entire command, and thus keep track of whether or not
we have to return an error because an undefined variable was used in a
non-optional part of the command.

<<constant definitions>>=
#define MAX_OPT_DEPTH 10
@ 

<<variables local to parse>>=
size_t old_pos[MAX_OPT_DEPTH] = {0};
int okay[MAX_OPT_DEPTH] = {1};
int opt_depth = 1;
@ 

Given this, when we encounter a double open bracket, we need to just
add the appropriate values to our stacks, and, similarly, when we
encounter a double close bracket, we simply need to pop the stack, and
see whether we need to move back or not, as well as taking care of an
possible errors, naturally. \emph{We probably could actually give
error messages here instead of just treating the brackets literally
when they might cause problems. But there doesn't seem much point,
really. --- aj}

<<handle a token>>=
case '[':
	if (command[1] == '[' && opt_depth < MAX_OPT_DEPTH) {
		old_pos[opt_depth] = pos;
		okay[opt_depth] = 1;
		opt_depth++;
		command += 2;
	} else {
		addstr(&result, &len, &pos, "[", 1);
		command++;
	}
	break;
@ 

<<handle a token>>=
case ']':
	if (command[1] == ']' && opt_depth > 1) {
		opt_depth--;
		if (!okay[opt_depth]) {
			pos = old_pos[opt_depth];
			result[pos] = '\0';
		}
		command += 2;
	} else {
		addstr(&result, &len, &pos, "]", 1);
		command++;
	}
	break;
@

Finally, at the end of the function, the stacks can be left in an
unacceptable state --- either one of the optional blocks was never
closed, or an undefined variable was used elsewhere. We'll note these
circumstances by returning [[NULL]] and setting [[errno]].

<<execute headers>>=
#include <errno.h>
@

<<constant definitions>>=
#define EUNBALBRACK 10001
#define EUNDEFVAR   10002
@ 

<<deal with error conditions>>=
if (opt_depth > 1) {
	errno = EUNBALBRACK;
	free(result);
	return NULL;
}

if (!okay[0]) {
	errno = EUNDEFVAR;
	free(result);
	return NULL;
}
@ 

\subsubsection{Variables}

Dealing with variables is comparatively fairly simple. We just need to
find the next percent, and see if whatever's inbetween is a variable,
and, if so, get it's value.

<<constant definitions>>=
#define MAX_VARNAME   32
#define EUNBALPER   10000
@ 

<<handle a token>>=
case '%':
{
	<<variables local to handle percent token>>
	char *varvalue;

	<<determine variable name>>

	<<get [[varvalue]]>>

	if (varvalue) {
		addstr(&result, &len, &pos, varvalue, strlen(varvalue));
	} else {
		okay[opt_depth - 1] = 0;
	}

	<<move to token after closing percent>>
	
	break;
}
@ 

We don't do anything particularly clever dealing with the next percent
--- just a pointer to the appropriate character.

<<variables local to handle percent token>>=
char *nextpercent;
@ 

<<determine variable name>>=
command++;
nextpercent = strchr(command, '%');
if (!nextpercent) {
	errno = EUNBALPER;
	free(result);
	return NULL;
}
@ 

<<move to token after closing percent>>=
command = nextpercent + 1;
@

The slightly tricky thing we do here is use a [[strncmpz]] function,
which allows us to check that a string represented by a [[char*]] and
a length is the same as a [[NUL]] terminated string.

<<execute function declarations>>=
int strncmpz(char *l, char *r, size_t llen);
@ 

<<execute functions>>=
int strncmpz(char *l, char *r, size_t llen) {
	int i = strncmp(l, r, llen);
	if (i == 0)
		return -r[llen];
	else
		return i;
}
@ 

Given the above, the implementation of the [[get_var()]] function to
lookup the value of a variable, is reasonably straight forward.

<<execute function declarations>>=
char *get_var(char *id, size_t idlen, interface_defn *ifd);
@ 

<<execute functions>>=
char *get_var(char *id, size_t idlen, interface_defn *ifd) {
	int i;

	if (strncmpz(id, "iface", idlen) == 0) {
		return ifd->iface;
	} else {
		for (i = 0; i < ifd->n_options; i++) {
			if (strncmpz(id, ifd->option[i].name, idlen) == 0) {
				return ifd->option[i].value;
			}
		}
	}

	return NULL;
}
@ 

Which means we can finish of the chunk, thus:

<<get [[varvalue]]>>=
varvalue = get_var(command, nextpercent - command, ifd);
@ 

\section{The Driver}

\emph{Guess where I stopped. You might be better off looking at the
generated file to get the gist of what this does. Hopefully it's not
\textbf{too} complicated.}

<<main.c>>=
<<main headers>>

<<main function declarations>>
<<main functions>>

<<main>>
@ 

<<main headers>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <assert.h>
#include <getopt.h>

#include "header.h"
@

<<main function declarations>>=
static int check(char *str);
@

<<main functions>>=
static int check(char *str) {
	return str != NULL;
}
@ 

<<main function declarations>>=
static int doit(char *str);
@ 

<<main functions>>=
static int doit(char *str) {
	system(str);
	return 1;
}
@

<<main function declarations>>=
static int printit(char *str);
@

<<main functions>>=
static int printit(char *str) {
	printf("  %s\n", str); fflush(stdout);
	return 1;
}
@


<<main function declarations>>=
static int execute_all(interface_defn *ifd, int(*exec)(char*), char *opt);
@ 

<<main functions>>=
static int execute_all(interface_defn *ifd, int(*exec)(char*), char *opt) {
	int i;
	for (i = 0; i < ifd->n_options; i++) {
		if (strcmp(ifd->option[i].name, opt) == 0) {
			if (!exec(ifd->option[i].value)) {
				return 0;
			}
		}
	}
	return 1;
}
@ 

<<main function declarations>>=
static int up(interface_defn *iface, int (*exec)(char*));
@ 

<<main function declarations>>=
static int up(interface_defn *iface, int (*exec)(char*));
@ 

<<main functions>>=
static int up(interface_defn *iface, int (*exec)(char*)) {
	if (!execute_all(iface,exec,"pre-up")) return 0;
	if (!iface->method->up(iface,exec)) return 0;
	if (!execute_all(iface,exec,"up")) return 0;

	return 1;
}
@ 

<<main function declarations>>=
static int down(interface_defn *iface, int (*exec)(char*));
@ 

<<main functions>>=
static int down(interface_defn *iface, int (*exec)(char*)) {
	if (!execute_all(iface,exec,"down")) return 0;
	if (!iface->method->down(iface,exec)) return 0;
	if (!execute_all(iface,exec,"post-down")) return 0;

	return 1;
}
@ 

<<main>>=
int main(int argc, char **argv) {
	int i;

	char *interfaces = "/etc/network/interfaces";
  
	interface_defn *ifaces = NULL;
	interface_defn *currif = NULL;

	<<variables local to main>>

	<<parse command name>>
	<<parse arguments>>

	ifaces = read_interfaces(interfaces);
	if ( !ifaces ) {
		exit(1);
	}

	<<run [[cmds]] for appropriate interfaces>>
  
	return 0;
}
@

<<variables local to main>>=
int (*cmds)(interface_defn *, int (*exec)(char*)) = NULL;
char *command;
@ 

<<parse command name>>=
command = strrchr(argv[0],'/');
if (command == NULL) {
	command = argv[0];
} else {
	command++;
}

if (strcmp(command, "ifup")==0) {
	cmds = up;
} else if (strcmp(command, "ifdown")==0) {
	cmds = down;
} else {
	fprintf(stderr,"This command should be called as ifup or ifdown\n");
	exit(1);
}
@   

<<variables local to main>>=
struct option long_opts[] = {
	{"scheme",     required_argument, NULL, 's'},
	{"help",       no_argument,       NULL, 'h'},
	{"verbose",    no_argument,       NULL, 'v'},
	{"all",        no_argument,       NULL, 'a'},
	{"interfaces", required_argument, NULL, 'i'},
	{"no-act",     no_argument,       NULL, 'n'},
	{0,0,0,0}
};

int do_all = 0;
int no_act = 0;
int verbose = 0;
char *real_scheme = "*";
@ 

<<main functions>>=
static void usage(void) {
	fprintf(stderr, "Use --help for help\n");
	exit(1);
}
@ 

<<main functions>>=
static void help(char *execname) {
	printf("Usage: %s -anvsh -i<file> <ifaces...>\n\n", execname);
	printf("\t-a --all\t\tde/configure all interfaces automatically\n");
	printf("\t-s --scheme SCHEME\tuse SCHEME as scheme\n");
	printf("\t-h --help\t\tthis help\n");
	printf("\t-i --interfaces FILE\tuse FILE for interface definitions\n");
	printf("\t-n --no-act\t\tprint out what would happen, but don't do it\n");
	printf("\t-v --verbose\t\tprint out what would happen before doing it\n");
	exit(0);
}
@ 

<<parse arguments>>=
for (;;) {
	int c;
	c = getopt_long(argc, argv, "s:i:hvna", long_opts, NULL);
	if (c == EOF) break;

	switch(c) {
		case 's':
			real_scheme = strdup(optarg);
			break;
		case 'i':
			interfaces = strdup(optarg);
			break;
		case 'h':
			help(argv[0]);
			break;
		case 'v':
			verbose = 1;
			break;
		case 'a':
			do_all = 1;
			break;
		case 'n':
			no_act = 1;
			break;
		default:
			usage();
			break;
	}
}

if (argc - optind == 0 && !do_all) {
	usage();
}

if (argc - optind > 0 && do_all) {
	usage();
}
@ 

<<run [[cmds]] for appropriate interfaces>>=
if (do_all) {
	<<run [[cmds]] for all interfaces>>
} else {
	<<run [[cmds]] for given arguments>>
}
@

<<main headers>>=
#include <fnmatch.h>
@ 

<<run [[cmds]] for given arguments>>=
for (i = optind; i < argc; i++) {
	int okay;
	okay = 0;
	for (currif = ifaces; currif; currif = currif->next) {
		if (strcmp(argv[i],currif->iface) == 0 
			&& fnmatch(currif->scheme, real_scheme, 0) == 0) 
		{
			okay = 1;
			<<run [[cmds]] for [[currif]]>>
			break;
		}
	}
	if (!okay) {
		fprintf(stderr, "Ignoring unknown interface %s.\n",
			argv[i]);
	}
}
@

<<run [[cmds]] for all interfaces>>=
for (currif = ifaces; currif; currif = currif->next) {
	if (!currif->automatic 
		|| fnmatch(currif->scheme, real_scheme, 0) != 0) 
	{
		continue;
	}

	<<run [[cmds]] for [[currif]]>>
}
@ 

<<run [[cmds]] for [[currif]]>>=
if ( !cmds(currif,check) ) {
	printf("Don't seem to be have all the variables for %s.\n", currif->iface);
} else {
	if (no_act || verbose) {
		cmds(currif,printit);
	}
	if (!no_act) {
		cmds(currif,doit);
	}
}
@ 

\appendix

\section{Linux Address Families}

<<archlinux.h>>=
unsigned int mylinuxver();
unsigned int mylinux(int,int,int);
int execable(char *);
@

<<archlinux.c>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/stat.h>

#include "archlinux.h"

unsigned int mylinuxver() {
	static int maj = -1, rev, min;

	if (maj == -1) {
		struct utsname u;
		char *pch;
		uname(&u);
		maj = atoi(u.release);
		pch = strchr(u.release, '.');
		rev = atoi(pch+1);
		pch = strchr(pch+1, '.');
		min = atoi(pch+1);
	}

	return mylinux(maj,rev,min);
}

unsigned int mylinux(int maj, int rev, int min) { 
	return min | rev << 10 | maj << 13;
}

int execable(char *program) {
	struct stat buf;

	if (0 == stat(program, &buf)) {
		if (S_ISREG(buf.st_mode) && (S_IXUSR & buf.st_mode)) return 1;
	}
	return 0;
}
@ 

\subsection{IPv4 Address Family}

<<address family declarations>>=
extern address_family addr_inet;
@ 

<<address family references>>=
&addr_inet, 
@ 

<<inet.defn>>=
address_family inet
architecture linux

# isup
#     /* some code to check if an interface is up? */

<<inet methods>>
@ 

<<inet methods>>=
method loopback
  description
    This method may be used to define the IPv4 loopback interface.

  up
    ifconfig %iface% 127.0.0.1 up
    route add -net 127.0.0.0       if ( mylinuxver() < mylinux(2,1,100) )

  down
    ifconfig %iface% down
@ 

<<inet methods>>=
method static
  description
    This method may be used to define ethernet interfaces with statically
    allocated IPv4 addresses.
      
  options
    address address             -- Address (dotted quad) *required*
    netmask netmask             -- Netmask (dotted quad) *required*
    broadcast broadcast_address -- Broadcast address (dotted quad)
    network network_address     -- Network address (dotted quad) *required \
                                     for 2.0.x kernels*
    gateway address             -- Default gateway (dotted quad)

#??  code
#??    given %address%: possibly calculate %netmask%
#??    given %address%, %netmask%: calculate network, broadcast if necessary

  up
    ifconfig %iface% %address% netmask %netmask% [[broadcast %broadcast%]] up
    route add -net %network%  \
        if ( mylinuxver() < mylinux(2,1,100) )
    [[ route add default gw %gateway% ]]

  down
    ifconfig %iface% down
@ 

<<inet methods>>=
method dhcp
  description
    This method may be used to obtain an address via DHCP with any of
    the tools: dhclient, pump (2.2.x kernels only), or dhcpcd (2.0 and
    2.2 kernels only). If you have a complicated DHCP setup you should
    note that some of these clients use their own configuration files,
    rather than obtaining their configuration via *ifup*.

  options
    hostname hostname   -- Hostname to be requested (pump, dhcpcd)
    leasehours leastime -- Preferred lease time in hours (pump)
    leasetime leasetime -- Preferred lease time in seconds (dhcpcd)
    vendor vendor       -- Vendor class identifier (dhcpcd)
    client client_id    -- Client identifier (dhcpcd)

  up
    dhclient %iface%  \
        if (execable("/sbin/dhclient"))
    pump -i %iface% [[-h %hostname%]] [[-l %leasehours%]] \
        elsif (execable("/sbin/pump") && mylinuxver() >= mylinux(2,1,100))
    dhcpcd [[-h %hostname%]] [[-i %vendor%]] [[-I %clientid%]] \
           [[-l %leasetime%]] %iface% \
        elsif (execable("/sbin/dhcpcd"))

  down
    cat /var/run/dhclient.pid | xargs -i kill -TERM dhclient {} \
        if (execable("/sbin/dhclient"))
    pump -i %iface% -k \
        elsif (execable("/sbin/pump") && mylinuxver() >= mylinux(2,1,100))
    dhcpcd -k %iface% \
        elsif (execable("/sbin/dhcpcd"))

    ifconfig %iface% down
@ 

<<inet methods>>=
method bootp
  description
    This method may be used to obtain an address via bootp.

  options
    bootfile file  -- Tell the server to use /file/ as the bootfile.
    server address -- Use the IP address /address/ to communicate with \
                      the server.
    hwaddr addr    -- Use /addr/ as the hardware address instead of \
                      whatever it really is.

  up
    bootpc [[--bootfile %bootfile%]] --dev %iface% [[--server %server%]] \
           [[--hwaddr %hwaddr%]] --returniffail --serverbcast

  down
    ifconfig down %iface%
@ 

<<inet methods>>=
method ppp
  description
    This method uses pon/poff to configure a PPP interface. See those
    commands for details.
  up
    pon
  down
    poff
@ 

\subsection{IPv6 Address Family}

<<address family declarations>>=
extern address_family addr_inet6;
@ 

<<address family references>>=
&addr_inet6,
@ 

<<inet6.defn>>=
address_family inet6
architecture linux

method loopback
  up
    ifconfig %iface% add ::1
  down
    ifconfig %iface% del ::1
@ 

\subsection{IPX Address Family}

<<address family declarations>>=
extern address_family addr_ipx;
@ 

<<address family references>>=
&addr_ipx,
@ 

<<ipx.defn>>=
address_family ipx
architecture linux

method static
  options
    device
    ipx_frame
    ipx_netnum

  up
    ipx_interface add %device% %ipx_frame% %ipx_netnum%

  down
    ipx_interface del %device% %ipx_frame%
@ 

\begin{flushleft}
\bibliography{biblio}
\bibliographystyle{unsrt}
\end{flushleft}
